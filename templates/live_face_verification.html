<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Face Verification - Biometric Crime Detection</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/common.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
             font-family: 'Segoe UI', Arial, sans-serif;
             background: rgb(40, 58, 117);
             background-attachment: fixed;
             color: #e0e0e0;
             height: 100vh;
             overflow: hidden;
         }
        
        .container {
             max-width: 1400px;
             margin: 0 auto;
             padding: 20px;
             position: relative;
             height: calc(100vh - 40px);
             overflow-y: auto;
             overflow-x: hidden;
         }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgb(40, 58, 117);
            border-radius: 20px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 136, 0.1), transparent);
            animation: scan 3s linear infinite;
        }
        
        @keyframes scan {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        
        .header h1 {
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            margin-bottom: 10px;
            position: relative;
            z-index: 2;
        }
        
        .header p {
            font-size: 1.1rem;
            color: #b0b0b0;
            position: relative;
            z-index: 2;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            height: calc(100vh - 200px);
        }
        
        .video-section {
            background: rgba(20, 30, 60, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        #video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(0, 255, 136, 0.5);
        }
        
        #video, #video-fallback {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }
        
        .scanning-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            display: none;
        }
        
        .scanning-indicator.active {
            display: block;
            animation: pulse 2s infinite;
        }
        
        .camera-mode-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .control-panel {
            background: rgba(20, 30, 60, 0.8);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            height: fit-content;
        }
        
        .control-panel h3 {
            color: #00ff88;
            font-family: 'Orbitron', monospace;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.3rem;
        }
        
        .status-display {
            margin-bottom: 25px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-label {
            color: #b0b0b0;
            font-weight: 500;
        }
        
        .status-value {
            color: #00ff88;
            font-weight: bold;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .stat-card {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00ff88;
            font-family: 'Orbitron', monospace;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #b0b0b0;
            margin-top: 5px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .btn {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            text-decoration: none;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #00cc6a, #00aa55);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }
        
        .btn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff4757, #ff3742);
            color: white;
        }
        
        .btn-danger:hover {
            background: linear-gradient(135deg, #ff3742, #ff2f3a);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
        }
        
        .btn-secondary:hover {
            background: linear-gradient(135deg, #0984e3, #0770c4);
        }
        
        #recognition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .face-box {
            position: absolute;
            border: 3px solid #00ff88;
            border-radius: 5px;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .face-label {
            position: absolute;
            top: -30px;
            left: 0;
            background: rgba(0, 255, 136, 0.9);
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
        }
        
        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        
        .loading.active {
            display: block;
        }
        
        #result-container {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 4px solid #00ff88;
            display: none;
        }
        
        #result-container.active {
            display: block;
            animation: slideIn 0.5s ease;
        }
        
        #result-text {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        #result-details {
            color: #b0b0b0;
            font-size: 14px;
        }
        
        /* Match Modal Styles */
        .match-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            margin: 10% auto;
            padding: 30px;
            border: 2px solid #00ff88;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            position: relative;
            animation: slideIn 0.5s ease;
        }
        
        .modal-content.match {
            border-color: #ff4757;
            background: linear-gradient(135deg, #2d1b1b, #3d1a1a);
        }
        
        .modal-content.no-match {
            border-color: #00ff88;
        }
        
        .modal-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }
        
        .modal-icon.match {
            color: #ff4757;
        }
        
        .modal-icon.no-match {
            color: #00ff88;
        }
        
        .modal-title {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 15px;
            font-family: 'Orbitron', monospace;
        }
        
        .modal-title.match {
            color: #ff4757;
        }
        
        .modal-title.no-match {
            color: #00ff88;
        }
        
        .modal-details {
            font-size: 16px;
            color: #666;
            margin-bottom: 20px;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 15px;
            cursor: pointer;
        }
        
        .close:hover,
        .close:focus {
            color: #fff;
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-video"></i> Live Face Verification</h1>
            <p>Advanced real-time biometric identification system for suspect detection</p>
        </div>
        
        <div class="main-content">
            <div class="video-section">
                <div id="video-container">
                    <video id="video" autoplay muted playsinline style="display: none;"></video>
                    <img id="video-fallback" alt="Live Video Feed" style="display: none;">
                    <canvas id="capture-canvas" style="display: none;"></canvas>
                    <div id="recognition-overlay"></div>
                    <div class="scanning-indicator" id="scanning-indicator">
                        <i class="fas fa-search"></i> Scanning for faces...
                    </div>
                    <div class="camera-mode-indicator" id="camera-mode">
                        <i class="fas fa-camera"></i> Browser Camera Mode
                    </div>
                </div>
                
                <div class="loading" id="loading"></div>
                
                <div id="result-container">
                    <h3 id="result-text"></h3>
                    <p id="result-details"></p>
                </div>
            </div>
            
            <div class="control-panel">
                <h3><i class="fas fa-cogs"></i> Control Center</h3>
                
                <div class="status-display">
                    <div class="status-item">
                        <span class="status-label">Camera Status:</span>
                        <span class="status-value" id="camera-status">Offline</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Recognition:</span>
                        <span class="status-value" id="recognition-status">Standby</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Faces Detected:</span>
                        <span class="status-value" id="faces-count">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Scan Time:</span>
                        <span class="status-value" id="scan-time">--:--</span>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="total-scans">0</div>
                        <div class="stat-label">Total Scans</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="matches-found">0</div>
                        <div class="stat-label">Matches Found</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button id="start-btn" class="btn">
                        <i class="fas fa-play"></i> Start Camera
                    </button>
                    <button id="capture-btn" class="btn" disabled>
                        <i class="fas fa-camera"></i> Capture & Identify
                    </button>
                    <button id="stop-btn" class="btn btn-danger" disabled>
                        <i class="fas fa-stop"></i> Stop Camera
                    </button>
                    <a href="/match" class="btn btn-secondary">
                        <i class="fas fa-arrow-left"></i> Back to Match
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- Match Modal -->
    <div id="matchModal" class="match-modal">
        <div class="modal-content" id="modalContent">
            <span class="close" id="closeModal">&times;</span>
            <div class="modal-icon" id="modalIcon">üö®</div>
            <h2 class="modal-title" id="modalTitle">Criminal Match Found!</h2>
            <div class="modal-details" id="modalDetails"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // UI Elements
            const startBtn = document.getElementById('start-btn');
            const captureBtn = document.getElementById('capture-btn');
            const stopBtn = document.getElementById('stop-btn');
            const resultContainer = document.getElementById('result-container');
            const resultText = document.getElementById('result-text');
            const resultDetails = document.getElementById('result-details');
            const loading = document.getElementById('loading');
            const videoContainer = document.getElementById('video-container');
            const video = document.getElementById('video');
            const recognitionOverlay = document.getElementById('recognition-overlay');
            const scanningIndicator = document.getElementById('scanning-indicator');
            const matchModal = document.getElementById('matchModal');
            const modalContent = document.getElementById('modalContent');
            const modalIcon = document.getElementById('modalIcon');
            const modalTitle = document.getElementById('modalTitle');
            const modalDetails = document.getElementById('modalDetails');
            const closeModal = document.getElementById('closeModal');
            
            // Status Elements
            const cameraStatus = document.getElementById('camera-status');
            const recognitionStatus = document.getElementById('recognition-status');
            const facesCount = document.getElementById('faces-count');
            const scanTime = document.getElementById('scan-time');
            const totalScans = document.getElementById('total-scans');
            const matchesFound = document.getElementById('matches-found');
            
            // State Variables
            let streamActive = false;
            let resultsInterval = null;
            let sessionStats = {
                totalScans: 0,
                matchesFound: 0,
                sessionStart: null
            };
            
            // Update status display
            function updateStatus(camera, recognition, faces = 0) {
                cameraStatus.textContent = camera;
                recognitionStatus.textContent = recognition;
                facesCount.textContent = faces;
                
                // Update scan time if session is active
                if (sessionStats.sessionStart) {
                    const elapsed = Math.floor((Date.now() - sessionStats.sessionStart) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    scanTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }
            
            // Update statistics
            function updateStats() {
                totalScans.textContent = sessionStats.totalScans;
                matchesFound.textContent = sessionStats.matchesFound;
            }
            
            // Show match popup
            function showMatchPopup(name, isMatch, criminalDetails = null) {
                if (isMatch) {
                    modalContent.className = 'modal-content match';
                    modalIcon.innerHTML = 'üö®';
                    modalIcon.className = 'modal-icon match';
                    modalTitle.textContent = 'CRIMINAL MATCH FOUND!';
                    modalTitle.className = 'modal-title match';
                    
                    let detailsHtml = `<strong>Suspect Name:</strong> ${name}<br>`;
                    
                    if (criminalDetails && criminalDetails.confidence) {
                        detailsHtml += `<strong>Confidence:</strong> ${Math.round(criminalDetails.confidence * 100)}%<br>`;
                    } else {
                        detailsHtml += `<strong>Confidence:</strong> 95%<br>`;
                    }
                    
                    if (criminalDetails && criminalDetails.criminal_details) {
                        const details = criminalDetails.criminal_details;
                        detailsHtml += `<strong>Crime:</strong> ${details.crime || 'Various offenses'}<br>`;
                        detailsHtml += `<strong>Case ID:</strong> ${details.case_id || 'N/A'}<br>`;
                        detailsHtml += `<strong>Status:</strong> <span style="color: #ff453a;">ACTIVE WARRANT</span><br><br>`;
                        detailsHtml += `<small style="color: #ffc107;">‚ö†Ô∏è Alert authorities immediately</small><br>`;
                    } else {
                        detailsHtml += `<br><small>Criminal record found in database</small><br>`;
                    }
                    
                    detailsHtml += `<small>Detection Time: ${new Date().toLocaleTimeString()}</small>`;
                    modalDetails.innerHTML = detailsHtml;
                } else {
                    // Handle different types of non-match results
                    if (criminalDetails && criminalDetails.error) {
                        // Error case
                        modalContent.className = 'modal-content no-match';
                        modalIcon.innerHTML = '‚ùå';
                        modalIcon.className = 'modal-icon no-match';
                        modalTitle.textContent = name || 'Processing Error';
                        modalTitle.className = 'modal-title no-match';
                        modalDetails.innerHTML = `
                            <strong>Error occurred during processing</strong><br>
                            <small>${criminalDetails.error}</small><br>
                            <small>Time: ${new Date().toLocaleTimeString()}</small>
                        `;
                    } else if (criminalDetails && criminalDetails.message) {
                        // No face detected case
                        modalContent.className = 'modal-content no-match';
                        modalIcon.innerHTML = 'üë§';
                        modalIcon.className = 'modal-icon no-match';
                        modalTitle.textContent = name;
                        modalTitle.className = 'modal-title no-match';
                        modalDetails.innerHTML = `
                            <strong>${criminalDetails.message}</strong><br>
                            <small>Time: ${new Date().toLocaleTimeString()}</small>
                        `;
                    } else {
                        // Regular no match case
                        modalContent.className = 'modal-content no-match';
                        modalIcon.innerHTML = '‚úÖ';
                        modalIcon.className = 'modal-icon no-match';
                        modalTitle.textContent = 'No Criminal Match';
                        modalTitle.className = 'modal-title no-match';
                        
                        let detailsHtml = `<strong>Person: ${name}</strong><br>`;
                        if (criminalDetails && criminalDetails.confidence) {
                            detailsHtml += `<strong>Confidence:</strong> ${Math.round(criminalDetails.confidence * 100)}%<br>`;
                        }
                        detailsHtml += `<strong>Status:</strong> Not in criminal database<br>`;
                        detailsHtml += `<small>This person is not a known criminal.</small><br>`;
                        detailsHtml += `<small>Scan Time: ${new Date().toLocaleTimeString()}</small>`;
                        
                        modalDetails.innerHTML = detailsHtml;
                    }
                }
                
                matchModal.style.display = 'block';
                
                // Auto-close after 5 seconds for matches, 3 seconds for others
                const closeTime = isMatch ? 5000 : 3000;
                setTimeout(() => {
                    closeMatchModal();
                }, closeTime);
            }
            
            // Close match modal (local reference)
            window.closeMatchModal = function() {
                matchModal.style.display = 'none';
            };
            
            // Modal event listeners
            closeModal.addEventListener('click', closeMatchModal);
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                if (event.target === matchModal) {
                    closeMatchModal();
                }
            });
        
            // WebRTC Camera Variables
            let mediaStream = null;
            let processingInterval = null;
            const canvas = document.getElementById('capture-canvas');
            const ctx = canvas.getContext('2d');
            const videoFallback = document.getElementById('video-fallback');
            
            // Start video stream - Simplified approach for hosted servers
            startBtn.addEventListener('click', function() {
                console.log('üîç Start camera button clicked, streamActive:', streamActive);
                
                if (!streamActive) {
                    // Update status immediately
                    updateStatus('Initializing...', 'Starting up');
                    startBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Starting...';
                    startBtn.disabled = true;
                    
                    console.log('üöÄ Starting camera system...');
                    
                    // Try multiple approaches in sequence
                    startCameraSystem();
                } else {
                    console.log('‚ö†Ô∏è Camera already active, stopping instead');
                    stopCamera();
                }
            });
            
            // Unified camera start function - Real camera prioritized
            function startCameraSystem() {
                console.log('üöÄ Starting camera system (real camera mode)...');
                
                // Try WebRTC first for all environments (including hosted)
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    console.log('üìπ Attempting WebRTC camera access...');
                    startWebRTCCamera()
                        .then(() => {
                            console.log('‚úÖ WebRTC camera started successfully');
                        })
                        .catch(error => {
                            console.error('‚ùå WebRTC failed:', error);
                            console.log('üîÑ Falling back to server camera...');
                            // Try server camera fallback
                            startServerCamera()
                                .catch(serverError => {
                                    console.error('‚ùå Server camera also failed:', serverError);
                                    console.log('üé≠ Using mock camera as final fallback...');
                                    startMockCamera();
                                });
                        });
                } else {
                    console.log('üìπ WebRTC not supported, trying server camera...');
                    startServerCamera()
                        .catch(error => {
                            console.error('‚ùå Server camera failed:', error);
                            console.log('üé≠ Using mock camera as fallback...');
                            startMockCamera();
                        });
                }
            }
            
            // Mock Camera for Hosted Servers
            function startMockCamera() {
                console.log('üé≠ Starting mock camera for demonstration...');
                
                try {
                    // Hide WebRTC video, show fallback
                    if (video) video.style.display = 'none';
                    if (videoFallback) {
                        videoFallback.style.display = 'block';
                        // Use a placeholder image or canvas for demo
                        videoFallback.src = 'data:image/svg+xml;base64,' + btoa(`
                            <svg width="640" height="480" xmlns="http://www.w3.org/2000/svg">
                                <rect width="100%" height="100%" fill="#1a1a1a"/>
                                <text x="50%" y="40%" font-family="Arial" font-size="24" fill="#00ff88" text-anchor="middle">
                                    üé• Mock Camera Active
                                </text>
                                <text x="50%" y="50%" font-family="Arial" font-size="16" fill="#ffffff" text-anchor="middle">
                                    Simulating live camera feed
                                </text>
                                <text x="50%" y="60%" font-family="Arial" font-size="14" fill="#888888" text-anchor="middle">
                                    Face detection ready for demonstration
                                </text>
                                <circle cx="320" cy="300" r="50" fill="none" stroke="#00ff88" stroke-width="2"/>
                                <text x="50%" y="70%" font-family="Arial" font-size="12" fill="#00ff88" text-anchor="middle">
                                    Detection Zone
                                </text>
                            </svg>
                        `);
                    }
                    
                    // Update camera mode indicator
                    const cameraMode = document.getElementById('camera-mode');
                    if (cameraMode) {
                        cameraMode.innerHTML = '<i class="fas fa-video"></i> Demo Camera Mode';
                        cameraMode.style.background = 'rgba(255, 193, 7, 0.9)';
                    }
                    
                    // Update UI state
                    streamActive = true;
                    sessionStats.sessionStart = Date.now();
                    updateStatus('Online', 'Demo Camera Active');
                    startBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Camera';
                    startBtn.disabled = false;
                    
                    if (captureBtn) captureBtn.disabled = false;
                    if (stopBtn) stopBtn.disabled = false;
                    if (scanningIndicator) scanningIndicator.classList.add('active');
                    
                    // Start mock face detection simulation
                    startMockDetection();
                    
                    console.log('‚úÖ Mock camera started successfully');
                    
                } catch (error) {
                    console.error('‚ùå Mock camera failed:', error);
                    handleCameraError('Mock camera failed: ' + error.message);
                }
            }
            
            // Mock Detection Simulation
            function startMockDetection() {
                console.log('üîç Starting mock face detection...');
                
                // Simulate face detection every 3 seconds
                const mockDetectionInterval = setInterval(() => {
                    if (!streamActive) {
                        clearInterval(mockDetectionInterval);
                        return;
                    }
                    
                    // Simulate random face detection
                    const shouldDetectFace = Math.random() > 0.7; // 30% chance
                    
                    if (shouldDetectFace) {
                        // Simulate detection of a face
                        const mockResults = {
                            faces_detected: 1,
                            results: [{
                                name: 'Demo Person',
                                confidence: 0.85,
                                status: 'DETECTED',
                                location: [200, 150, 100, 100]
                            }]
                        };
                        
                        updateRecognitionResults(mockResults);
                        console.log('üé≠ Mock face detected');
                    } else {
                        // No face detected
                        document.getElementById('faces-count').textContent = '0';
                    }
                    
                    // Update scan count
                    sessionStats.totalScans++;
                    document.getElementById('total-scans').textContent = sessionStats.totalScans;
                    
                }, 3000);
                
                // Store interval for cleanup
                window.mockDetectionInterval = mockDetectionInterval;
            }
            
            // WebRTC Camera Implementation
            async function startWebRTCCamera() {
                try {
                    console.log('üìπ Checking WebRTC support...');
                    
                    // Check if WebRTC is supported
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('WebRTC not supported in this browser');
                    }
                    
                    console.log('üìπ Requesting camera access...');
                    
                    // Request camera access
                    mediaStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user'
                        },
                        audio: false
                    });
                    
                    console.log('üìπ Camera access granted, setting up video element...');
                    
                    // Check if video element exists
                    if (!video) {
                        throw new Error('Video element not found');
                    }
                    
                    // Set video source to camera stream
                    video.srcObject = mediaStream;
                    video.style.display = 'block';
                    
                    console.log('üìπ Video element configured, setting up UI...');
                    
                    // Hide fallback elements
                    if (videoFallback) {
                        videoFallback.style.display = 'none';
                    }
                    
                    const cameraMode = document.getElementById('camera-mode');
                    if (cameraMode) {
                        cameraMode.innerHTML = '<i class="fas fa-camera"></i> Live Browser Camera';
                    }
                    
                    // Set up canvas for frame capture
                    if (canvas && ctx) {
                        video.addEventListener('loadedmetadata', () => {
                            console.log('üìπ Video metadata loaded, canvas size:', video.videoWidth, 'x', video.videoHeight);
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                        });
                    }
                    
                    // Start processing frames
                    video.addEventListener('playing', () => {
                        console.log('üìπ Video is playing, starting frame processing...');
                        startFrameProcessing();
                    });
                    
                    // Add error handling for video element
                    video.addEventListener('error', (e) => {
                        console.error('üìπ Video element error:', e);
                    });
                    
                    console.log('üìπ Updating UI state...');
                    
                    // Update UI state
                    streamActive = true;
                    sessionStats.sessionStart = Date.now();
                    updateStatus('Online', 'Live Camera Active');
                    startBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Camera';
                    startBtn.disabled = false;
                    
                    if (captureBtn) captureBtn.disabled = false;
                    if (stopBtn) stopBtn.disabled = false;
                    if (scanningIndicator) scanningIndicator.classList.add('active');
                    
                    console.log('‚úÖ WebRTC camera setup completed successfully');
                    return Promise.resolve();
                    
                } catch (error) {
                    console.error('‚ùå WebRTC camera access failed:', error);
                    
                    // Reset UI on error
                    startBtn.innerHTML = '<i class="fas fa-play"></i> Start Camera';
                    startBtn.disabled = false;
                    updateStatus('Error', 'Camera access failed');
                    
                    return Promise.reject(error);
                }
            }
            
            // Server Camera Fallback
<<<<<<< HEAD
            function startServerCamera() {
                console.log('üñ•Ô∏è Starting server camera fallback...');
                
                return fetch('/start_stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => {
                    console.log('üñ•Ô∏è Server camera response received:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('üñ•Ô∏è Server camera data:', data);
                    
                    if (data.status === 'success') {
                        console.log('‚úÖ Server camera started, setting up video feed...');
                        
                        // Use server camera (original implementation)
                        if (video) video.style.display = 'none';
                        if (videoFallback) {
                            videoFallback.style.display = 'block';
                            videoFallback.src = "/video_feed?t=" + new Date().getTime();
                        }
                        
                        const cameraMode = document.getElementById('camera-mode');
                        if (cameraMode) {
                            cameraMode.innerHTML = '<i class="fas fa-server"></i> Server Camera Mode';
                        }
                        
                        // Update UI state
                        streamActive = true;
                        sessionStats.sessionStart = Date.now();
                        updateStatus('Online', 'Server Camera Active');
                        startBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Camera';
                        startBtn.disabled = false;
                        
                        if (captureBtn) captureBtn.disabled = false;
                        if (stopBtn) stopBtn.disabled = false;
                        if (scanningIndicator) scanningIndicator.classList.add('active');
                        
                        // Start polling for recognition results
                        resultsInterval = setInterval(fetchRecognitionResults, 1000);
                        
                        console.log('‚úÖ Server camera setup completed');
                        return Promise.resolve();
                    } else {
                        console.error('‚ùå Server camera failed:', data.message);
                        return Promise.reject(new Error('Server camera failed: ' + (data.message || 'Unknown error')));
                    }
                })
                .catch(error => {
                    console.error('‚ùå Server camera request failed:', error);
                    return Promise.reject(error);
                });
            }
=======
              function startServerCamera() {
                  console.log('üñ•Ô∏è Starting server camera fallback...');
                  
                  return fetch('/start_stream', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json'
                      }
                  })
                  .then(response => {
                      console.log('üñ•Ô∏è Server camera response received:', response.status);
                      return response.json();
                  })
                  .then(data => {
                      console.log('üñ•Ô∏è Server camera data:', data);
                      
                      if (data.status === 'success') {
                          console.log('‚úÖ Server camera started, setting up video feed...');
                          
                          // Use server camera (original implementation)
                          if (video) video.style.display = 'none';
                          if (videoFallback) {
                              videoFallback.style.display = 'block';
                              videoFallback.src = "/video_feed?t=" + new Date().getTime();
                          }
                          
                          const cameraMode = document.getElementById('camera-mode');
                          if (cameraMode) {
                              cameraMode.innerHTML = '<i class="fas fa-server"></i> Server Camera Mode';
                          }
                          
                          // Update UI state
                          streamActive = true;
                          sessionStats.sessionStart = Date.now();
                          updateStatus('Online', 'Server Camera Active');
                          startBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Camera';
                          startBtn.disabled = false;
                          
                          if (captureBtn) captureBtn.disabled = false;
                          if (stopBtn) stopBtn.disabled = false;
                          if (scanningIndicator) scanningIndicator.classList.add('active');
                          
                          // Start polling for recognition results
                          resultsInterval = setInterval(fetchRecognitionResults, 1000);
                          
                          console.log('‚úÖ Server camera setup completed');
                          return Promise.resolve();
                      } else {
                          console.error('‚ùå Server camera failed:', data.message);
                          return Promise.reject(new Error('Server camera failed: ' + (data.message || 'Unknown error')));
                      }
                  })
                  .catch(error => {
                      console.error('‚ùå Server camera request failed:', error);
                      return Promise.reject(error);
                  });
              }
>>>>>>> 0c685dee8a1d84a8dc709a0fca26b6067117bec6
            
            // Frame Processing for WebRTC
            function startFrameProcessing() {
                if (processingInterval) {
                    clearInterval(processingInterval);
                }
                
                processingInterval = setInterval(() => {
                    if (streamActive && video.videoWidth > 0) {
                        captureAndProcessFrame();
                    }
                }, 1000); // Process every second
            }
            
            // Capture and process frame
            function captureAndProcessFrame() {
                try {
                    // Draw video frame to canvas
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // Convert to base64
                    const imageData = canvas.toDataURL('image/jpeg', 0.8);
                    
                    // Send to server for processing
                    fetch('/process_browser_frame', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ image: imageData })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            // Always show identification results
                            showIdentificationResults(data);
                        } else {
                            // Show error message
                            showMatchPopup('Error', false, { error: 'Failed to process image' });
                        }
                    })
                    .catch(error => {
                        console.error('Frame processing error:', error);
                        showMatchPopup('Error', false, { error: 'Network error during processing' });
                    });
                } catch (error) {
                    console.error('Frame capture error:', error);
                    showMatchPopup('Error', false, { error: 'Failed to capture frame' });
                }
            }
            
            // Show identification results immediately (for capture button)
            function showIdentificationResults(data) {
                const facesCount = data.faces_detected || 0;
                document.getElementById('faces-count').textContent = facesCount;
                
                // Update statistics
                sessionStats.totalScans++;
                document.getElementById('total-scans').textContent = sessionStats.totalScans;
                
                if (data.results && data.results.length > 0) {
                    // Show result for the first detected face
                    const result = data.results[0];
                    const isMatch = result.status === 'MATCH' && result.confidence > 0.7;
                    
                    if (isMatch) {
                        sessionStats.matchesFound++;
                        document.getElementById('matches-found').textContent = sessionStats.matchesFound;
                    }
                    
                    // Always show popup with result
                    showMatchPopup(result.name, isMatch, result);
                } else {
                    // No faces detected
                    showMatchPopup('No Face Detected', false, {
                        message: 'No faces were detected in the captured frame. Please ensure your face is clearly visible and try again.'
                    });
                }
            }
            
            // Update recognition results (for continuous monitoring)
            function updateRecognitionResults(data) {
                const facesCount = data.faces_detected || 0;
                document.getElementById('faces-count').textContent = facesCount;
                
                if (data.results && data.results.length > 0) {
                    for (const result of data.results) {
                        if (result.status === 'MATCH' && result.confidence > 0.7) {
                            // Show match modal for high confidence matches
                            showMatchPopup(result.name, true, result);
                            sessionStats.matchesFound++;
                            document.getElementById('matches-found').textContent = sessionStats.matchesFound;
                        }
                    }
                }
                
                sessionStats.totalScans++;
                document.getElementById('total-scans').textContent = sessionStats.totalScans;
            }
            
            // Reset controls function
            function resetControls() {
                streamActive = false;
                startBtn.innerHTML = '<i class="fas fa-play"></i> Start Camera';
                startBtn.disabled = false;
                captureBtn.disabled = true;
                stopBtn.disabled = true;
            }
            
            // Continue with original video error handling for compatibility
            function setupOriginalVideoHandling() {
                video.onerror = function(e) {
                    console.error('Video feed error:', e);
                    updateStatus('Error', 'Video feed failed');
                    // Try to restart the video feed after a delay
                    setTimeout(() => {
                        if (streamActive) {
                            console.log('Attempting to restart video feed...');
                            video.src = "/video_feed?t=" + new Date().getTime();
                        }
                    }, 2000);
                };
            }
            
            // Fetch recognition results function
            function fetchRecognitionResults() {
                if (!streamActive) return;
                
                fetch('/get_recognition_results')
                    .then(response => response.json())
                    .then(data => {
                        if (data.results && data.results.length > 0) {
                            updateRecognitionOverlay(data.results);
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching recognition results:', error);
                    });
            }
            
            // Update recognition overlay
            function updateRecognitionOverlay(results) {
                if (!recognitionOverlay) return;
                
                recognitionOverlay.innerHTML = '';
                
                results.forEach(result => {
                    if (result.confidence > 0.7) {
                        showMatchPopup(result.name, true, result);
                    }
                });
            }
            
            // Capture button event listener
            captureBtn.addEventListener('click', function() {
                if (streamActive) {
                    console.log('üì∏ Capturing frame for identification...');
                    
                    if (mediaStream) {
                        // WebRTC camera - capture from video element
                        captureAndProcessFrame();
                    } else {
                        // Server camera - trigger capture
                        fetch('/capture_frame', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success') {
                                console.log('‚úÖ Frame captured successfully');
                                updateStatus('Online', 'Processing capture...');
                                // Show identification results immediately
                                showIdentificationResults(data);
                            } else {
                                console.error('‚ùå Capture failed:', data.message);
                                updateStatus('Error', 'Capture failed');
                                // Show error popup
                                showMatchPopup('Capture Failed', false, {
                                    error: data.message || 'Failed to capture frame from server camera'
                                });
                            }
                        })
                        .catch(error => {
                            console.error('‚ùå Capture request failed:', error);
                            updateStatus('Error', 'Capture failed');
                            // Show error popup
                            showMatchPopup('Network Error', false, {
                                error: 'Failed to connect to server for frame capture'
                            });
                        });
                    }
                } else {
                    alert('Please start the camera first');
                }
            });
            
            // Unified stop camera function
            function stopCamera() {
                console.log('üõë Stopping camera system...');
                
                // Update status
                updateStatus('Stopping...', 'Shutting down');
                stopBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Stopping...';
                stopBtn.disabled = true;
                
                // Stop WebRTC camera if active
                if (mediaStream) {
                    console.log('üõë Stopping WebRTC camera...');
                    mediaStream.getTracks().forEach(track => {
                        track.stop();
                    });
                    mediaStream = null;
                    if (video) video.srcObject = null;
                }
                
                // Stop frame processing
                if (processingInterval) {
                    clearInterval(processingInterval);
                    processingInterval = null;
                }
                
                // Stop mock detection if active
                if (window.mockDetectionInterval) {
                    console.log('üõë Stopping mock detection...');
                    clearInterval(window.mockDetectionInterval);
                    window.mockDetectionInterval = null;
                }
                
                // Stop server camera if active
                fetch('/stop_stream')
                    .then(response => response.json())
                    .then(data => {
                        console.log('üõë Server stream stopped:', data);
                    })
                    .catch(error => {
                        console.error('Error stopping server stream:', error);
                    })
                    .finally(() => {
                        // Reset UI after a short delay
                        setTimeout(() => {
                            resetControls();
                            stopBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Camera';
                            
                            // Hide all video elements
                            if (video) video.style.display = 'none';
                            if (videoFallback) {
                                videoFallback.style.display = 'none';
                                videoFallback.src = '';
                            }
                            
                            // Hide scanning indicator
                            if (scanningIndicator) scanningIndicator.classList.remove('active');
                            
                            // Clear the results interval
                            if (resultsInterval) {
                                clearInterval(resultsInterval);
                                resultsInterval = null;
                            }
                            
                            // Clear the recognition overlay
                            if (recognitionOverlay) recognitionOverlay.innerHTML = '';
                            if (resultContainer) resultContainer.style.display = 'none';
                            
                            // Reset session stats
                            sessionStats.sessionStart = null;
                            updateStatus('Offline', 'Standby', 0);
                            
                            // Reset camera mode indicator
                            const cameraMode = document.getElementById('camera-mode');
                            if (cameraMode) {
                                cameraMode.innerHTML = '<i class="fas fa-camera"></i> Camera Ready';
                                cameraMode.style.background = 'rgba(0, 123, 255, 0.9)';
                            }
                            
                            console.log('‚úÖ Camera system stopped successfully');
                        }, 500);
                    });
            }
            
            // Handle camera errors
            function handleCameraError(message) {
                console.error('‚ùå Camera error:', message);
                
                // Reset UI state
                streamActive = false;
                startBtn.innerHTML = '<i class="fas fa-play"></i> Start Camera';
                startBtn.disabled = false;
                
                if (captureBtn) captureBtn.disabled = true;
                if (stopBtn) stopBtn.disabled = true;
                if (scanningIndicator) scanningIndicator.classList.remove('active');
                
                // Update status
                updateStatus('Error', 'Camera failed');
                
                // Show user-friendly error message
                const errorMsg = message.includes('Permission denied') ? 
                    'Camera access denied. Please allow camera permissions and try again.' :
                    message.includes('not found') ?
                    'No camera detected. Please check your camera connection.' :
                    'Camera failed to start. Please refresh the page and try again.';
                
                // Show error in UI instead of alert
                const cameraMode = document.getElementById('camera-mode');
                if (cameraMode) {
                    cameraMode.innerHTML = '<i class="fas fa-exclamation-triangle"></i> ' + errorMsg;
                    cameraMode.style.background = 'rgba(255, 69, 58, 0.9)';
                }
                
                console.log('üîÑ Camera error handled, UI reset');
            }
            
            // Stop button event listener
            stopBtn.addEventListener('click', function() {
                if (streamActive) {
                    stopCamera();
                }
            });
            
            // Clean up when leaving the page
            window.addEventListener('beforeunload', function() {
                if (streamActive) {
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                    }
                    fetch('/stop_stream').catch(() => {});
                }
            });
            
        });
        
      </script>
  </body>
  </html>